#!/bin/bash
##########################################################
# Default Values
##########################################################
show_help=false
codeline=500
level=0
tree_depth=0
start_folder="."
# Arrays for ignoring or including or excluding
ignore_types=()
include_types=()
exclude_items=()

##########################################################
# Parse Parameters
##########################################################
while [[ $# -gt 0 ]]; do
  case $1 in
    --codeline)
      codeline="$2"
      shift 2
      ;;
    --ignore)
      # Allow multiple extensions in one --ignore parameter
      shift
      while [[ $# -gt 0 && ! "$1" =~ ^-- ]]; do
        ignore_types+=("$1")
        shift
      done
      ;;
    --include)
      # Allow multiple extensions in one --include parameter
      shift
      while [[ $# -gt 0 && ! "$1" =~ ^-- ]]; do
        include_types+=("$1")
        shift
      done
      ;;
    --level)
      level="$2"
      if ! [[ "$level" =~ ^[0-9]+$ ]]; then
        echo "Error: --level must be a numeric value"
        exit 1
      fi
      shift 2
      ;;
    --tree)
      tree_depth="$2"
      if ! [[ "$tree_depth" =~ ^[0-9]+$ ]]; then
        echo "Error: --tree must be a numeric value"
        exit 1
      fi
      shift 2
      ;;
    --folder)
      start_folder="$2"
      if [ ! -d "$start_folder" ]; then
        echo "Error: Specified folder does not exist"
        exit 1
      fi
      shift 2
      ;;
    --exclude)
      # Allow specifying multiple items to exclude
      shift
      while [[ $# -gt 0 && ! "$1" =~ ^-- ]]; do
        exclude_items+=("$1")
        shift
      done
      ;;
    --help|-h)
      show_help=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Debug output - uncomment if needed
# echo "ignore_types: ${ignore_types[*]}"
# echo "include_types: ${include_types[*]}"
# echo "exclude_items: ${exclude_items[*]}"

if [ "$show_help" = true ]; then
  echo "Usage: longchop [options]"
  echo ""
  echo "Description:"
  echo "  Longchop is a utility that displays file contents with line numbers and directory"
  echo "  structure in a readable format. It's designed to help developers easily explore"
  echo "  and share code bases."
  echo ""
  echo "Options:"
  echo "  --codeline X             Show only the first X lines of each file (default 500)."
  echo "                           This helps when dealing with very large files."
  echo ""
  echo "  --ignore .ext1 .ext2     Ignore files with specified extensions in the listing."
  echo "                           You can provide multiple extensions in a single parameter."
  echo "                           Example: --ignore .log .tmp .bak"
  echo ""
  echo "  --include .ext1 .ext2    Include additional file types beyond the default set."
  echo "                           You can provide multiple extensions in a single parameter."
  echo "                           Example: --include .md .conf .env"
  echo ""
  echo "  --level X                Show file details only X levels deep from root (default 0)."
  echo "                           Level 0 means unlimited depth."
  echo ""
  echo "  --tree X                 Display tree structure X levels deep (overrides --level for tree display)."
  echo "                           This allows you to see a broad structure while limiting detailed content."
  echo ""
  echo "  --folder path            Specify starting folder (default: current directory)."
  echo "                           The path can be relative or absolute."
  echo ""
  echo "  --exclude item1 item2    Exclude specific files or folders (space separated)."
  echo "                           You can provide paths like 'folder/subfolder' or just names."
  echo "                           Example: --exclude node_modules tests/fixtures oldcode"
  echo ""
  echo "  --help, -h               Show this help message."
  echo ""
  echo "Default Included File Types:"
  echo "  .Dockerfile, .tsx, .ts, .jsx, .js, .json, .html, .css, .scss, .yaml, .yml, .txt, .sh"
  echo ""
  echo "Examples:"
  echo "  longchop --level 2                                  # Show file details 2 levels deep"
  echo "  longchop --level 2 --tree 4                         # Show file details 2 levels deep, but tree structure 4 levels"
  echo "  longchop --folder /path/to/dir                      # Start from specified directory"
  echo "  longchop --include .md .conf --ignore .test.js      # Include markdown and config files, ignore test files"
  echo "  longchop --exclude tests docs/generated assets      # Exclude multiple directories"
  exit 0
fi

##########################################################
# Helper Functions
##########################################################
function create_separator() {
    echo "───────┼────────────────────────────────────────────────────────────────────────"
}

function create_separator_bottom() {
    echo "───────┴────────────────────────────────────────────────────────────────────────"
}

function copy_to_clipboard() {
    # Try Mac first, then Linux if Mac fails
    cat - | pbcopy 2>/dev/null || cat - | xclip -selection clipboard 2>/dev/null || true
}

function display_file_content() {
    local file="$1"
    # Check if file exists and is readable
    if [[ ! -f "$file" || ! -r "$file" ]]; then
        echo "       │ ERROR: File not found or not readable: $file"
        create_separator_bottom
        echo
        return
    fi
    
    echo "       │ File: $file"
    create_separator
    # Only show up to $codeline lines
    line_num=1
    while IFS= read -r line || [[ -n "$line" ]]; do
        if (( line_num > codeline )); then
            break
        fi
        printf "%4d   │ %s\n" "$line_num" "$line"
        ((line_num++))
    done < "$file"
    
    create_separator_bottom
    echo
}

##########################################################
# Main Logic
##########################################################
{
    # Change to start folder if specified
    cd "$start_folder" || exit 1

    # 1. Print directory structure
    echo "Directory Structure:"
    echo "==================="
    current_dir=$(basename "$PWD")
    echo "$current_dir"

    # Use tree_depth if specified, otherwise use level
    display_depth=$level
    if [ "$tree_depth" -gt 0 ]; then
        display_depth=$tree_depth
    fi

    # Build exclusion string for tree command
    tree_exclusions="node_modules|.git|dist|build|.next|coverage"
    
    # Add custom exclusions to tree view
    for item in "${exclude_items[@]}"; do
        # Escape any pipe characters in the exclusion item
        escaped_item=$(echo "$item" | sed 's/|/\\|/g')
        tree_exclusions="${tree_exclusions}|${escaped_item}"
    done
    
    # Apply ignore_types to tree view as well
    for ext in "${ignore_types[@]}"; do
        # Remove leading dot if present and escape any special characters
        clean_ext=$(echo "$ext" | sed 's/^\.//' | sed 's/|/\\|/g')
        tree_exclusions="${tree_exclusions}|.*\.${clean_ext}$"
    done

    if [ "$display_depth" -gt 0 ]; then
        tree -L "$display_depth" -I "$tree_exclusions" --dirsfirst | tail -n +2
    else
        tree -I "$tree_exclusions" --dirsfirst | tail -n +2
    fi

    echo
    echo "Files with Contents:"
    echo "==================="

    # Build the find command with careful attention to quoting
    find_cmd="find . -type f \\( "
    
    # Add default file types
    default_types=(
        "*.Dockerfile" "*.tsx" "*.ts" "*.jsx" "*.js" 
        "*.json" "*.html" "*.css" "*.scss" "*.yaml" 
        "*.yml" "*.txt" "*.sh"
    )
    
    # Join default types with -o
    for ((i=0; i<${#default_types[@]}; i++)); do
        find_cmd+="-name '${default_types[i]}'"
        if ((i < ${#default_types[@]}-1)); then
            find_cmd+=" -o "
        fi
    done
    
    # Close the initial group
    find_cmd+=" \\)"

    # Add include types if any
    if [ ${#include_types[@]} -gt 0 ]; then
        find_cmd+=" -o \\( "
        for ((i=0; i<${#include_types[@]}; i++)); do
            find_cmd+="-name '*${include_types[i]}'"
            if ((i < ${#include_types[@]}-1)); then
                find_cmd+=" -o "
            fi
        done
        find_cmd+=" \\)"
    fi

    # Standard exclusions
    std_exclusions=(
        "*/node_modules/*" "*/.git/*" "*/dist/*"
        "*/build/*" "*/.next/*" "*/coverage/*"
    )
    
    for excl in "${std_exclusions[@]}"; do
        find_cmd+=" -not -path '$excl'"
    done

    # Add custom exclusions if any
    for item in "${exclude_items[@]}"; do
        # Handle both filenames and directory paths - being careful with quoting
        find_cmd+=" -not -name '$item' -not -path '*/$item' -not -path '*/$item/*'"
    done

    # Add ignore types if any
    for ext in "${ignore_types[@]}"; do
        find_cmd+=" -not -iname '*$ext'"
    done

    # Add maxdepth if level is specified
    if [ "$level" -gt 0 ]; then
        find_cmd+=" -maxdepth $((level + 1))"
    fi

    # Debug - uncomment if needed
    # echo "Find command: $find_cmd"
    
    # Execute the find command and process results
    file_list=$(eval "$find_cmd" 2>/dev/null)
    
    if [ -z "$file_list" ]; then
        echo "No matching files found."
    else
        echo "$file_list" | while IFS= read -r file; do
            # Skip if file doesn't exist (might have been deleted during processing)
            [ -f "$file" ] || continue
            
            dir_path=$(dirname "$file")
            if [ "$dir_path" = "." ]; then
                # File is in current directory
                echo "├── $(basename "$file")"
            else
                # File is in subdirectory
                echo "$dir_path" | sed 's/\.\///' | sed 's/[^/]*\//│   /g'
                echo "├── $(basename "$file")"
            fi
            display_file_content "$file"
        done
    fi
} | tee >(copy_to_clipboard)